1.编写格式
新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行
输入一些代码，第一行一般是这样：
#!/bin/bash
#!/usr/bin/php
"#!"是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行
2.运行
（1）方法一：作为可执行程序
chmod +x test.sh
./test.sh
ps1:第二行一定要写成./test.sh，而不是test.sh。直接写test.sh，linux会去PATH里寻找有没有叫test.sh的，而PATH中只有 /bin, /sbin, /usr/bin, /usr/sbin等，你的当前目录不在PATH里，所以写test.sh是找不到命令的，要用 ./test.sh告诉系统，就在当前目录找
ps2.通过这种方式运行shell脚本，代码第一行务必写对，让shell找到正确的解释器
（2）方法二：作为解释器参数---直接运行解释器，其参数就是shell脚本的文件名，如：
/bin/sh test.sh
/bin/php test.php
ps：以这种方式运行的脚本，不需要在第一行指定解释器信息
--------------------------------------------------------------------
以下为语法部分：
--------------------------------------------------------------------
1.变量
1.1 定义变量：左值=右值  
注意：“=”两边不能有空格
	首个字符不能以数字开头
	变量名中间不能有空格
	不能使用关键字
	可以以下划线开头
	* 可以用语句赋值：for file in `ls /etc`
或
for file in $(ls /etc)    //用法和功能类似于python的for循环
1.2 使用变量：在变量名前加美元符号，如：
your_name="qinjx"
echo $your_name
echo ${your_name}  //推荐加上花括号，这是个编程好习惯
ps：花括号加不加都可以，加花括号是为了帮助解释器识别变量的边界，如：
for skill in Ada Coffe Action Java; do
    echo "I am good at ${skill}Script"
done
1.3 只读变量
使用readonly命令可以将变量定义为只读变量，只读变量的值不能被改变
1.4 删除变量
使用unset命令可以删除变量：unset variable_name
ps：unset命令不能删除只读变量
1.5 变量类型
（1）局部变量
在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。
（2）环境变量
所有的程序（包括shell启动的程序）都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
（3）shell变量
shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行

2.shell字符串
2.1 单引号 str='this is a string'
注意：
（1）单引号里的任何字符都会原样输出，因此单引号字符串中的变量是无效的
（2）单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用，如：
your_name="runoob"
greeting_2='hello, '$your_name' !' 
输出：hello, runoob !
2.2 双引号 
注意：
（1）双引号里可以有变量
（2）双引号里可以出现转义字符
your_name="runoob"
# 使用双引号拼接
greeting="hello, "$your_name" !"
输出：hello, runoob !
2.3 获取字符串长度
string="abcd"
echo ${#string} #输出 4
2.4 截取子字符串（从0开始计算）
string="runoob is a great site"
echo ${string:1:4}   //截取第2个字符到第4个字符
输出:unoo
2.5 查找字符位置（从1开始计算）
//查找字符i或o的位置（哪个先出现就计算哪个）
string="runoob is a great site"
echo `expr index "$string" io` 
输出：4
3 shell数组（仅支持一位数组，用“空格”符号隔开）
3.1
array_name=(value0 value1 value2 value3)
3.2 单独定义数组的各个分量，可以使用不连续的下标，下标从0开始
array_name[0]=value0
array_name[1]=value1
array_name[n]=valuen
3.2 读取数组
法1：value2=${array_name[2]}
法2：使用 @ 符号可以获取数组中的所有元素，例如：
echo ${array_name[@]}
3.3 获取数组长度（方法与获取字符串长度的方法相同）
# 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
# 取得数组单个元素的长度
lengthn=${#array_name[n]}

4.shell注释
（1）以 # 开头的行就是注释
（2）对大段代码需要临时注释，每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。
（3）多行注释
:<<EOF
注释内容...
注释内容...
EOF
或
:<<'
注释内容...
注释内容...
注释内容...
'
或
:<<!
注释内容...
注释内容...
注释内容...
!
-------------------------------------------------------------------
5.shell传递参数（详见：https://www.runoob.com/linux/linux-shell-passing-arguments.html）
5.1 在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……
5.2 特殊字符的参数处理(这些字符相当于特殊含义的变量)
$#   //传递到脚本的参数个数
$*    //以一个单字符串显示所有向脚本传递的参数。
        如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。
$$    //脚本运行的当前进程ID号
$!     //后台运行的最后一个进程的ID号
$@   //与$*相同，但是使用时加引号，并在引号中返回每个参数。
       如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。
$-     //显示Shell使用的当前选项，与set命令功能相同。
$?     //显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
ps：$* 与 $@ 区别：
相同点：都是引用所有参数。
不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数）。

-------------------------------------------------------------------------
6.shell基本运算符
6.1 算术运算符
注意：下面的+ - * / 两边务必加上空格
+    加法     `expr $a + $b`
-     减法     `expr $a - $b`
*      乘法    `expr $a \* $b`  注意：* 号需要用 \ 进行转义
/      除法    `expr $b / $a`
%     取余    `expr $b % $a`
=     赋值     a=$b   注意：赋值时=号两边不能有空格
==   相等     [ $a == $b ]   注意：表达式两边的空格不能缺少
！=  不相等  [ $a != $b ]     注意：表达式两边的空格不能缺少
6.2 关系运算符
-eq   (=)检测两个数时候相等，相等返回true                             [ $a -eq $b ]
-ne   (!=)检测两个数是否不相等，不相等返回 true                     [ $a -ne $b ] 
-gt    (>)检测左边的数是否大于右边的，如果是，则返回 true      [ $a -gt $b ]
-lt     (<)检测左边的数是否小于右边的，如果是，则返回 true      [ $a -lt $b ] 
-ge    (>=)检测左边的数是否大于等于右边的，若是返回 true      [ $a -ge $b ]
-le     (<=)检测左边的数是否小于等于右边的，若是返回 true       [ $a -le $b ]
6.3 布尔运算符
！     非运算，表达式为 true 则返回 false，否则返回 true      [ ! false ]
-o     或运算，有一个表达式为 true 则返回 true       [ $a -lt 20 -o $b -gt 100 ]
-a     与运算，两个表达式都为 true 才返回 true       [ $a -lt 20 -a $b -gt 100 ]
6.4 逻辑运算符
&&   逻辑的 AND        [[ $a -lt 100 && $b -gt 100 ]]
||       逻辑的 OR           [[ $a -lt 100 || $b -gt 100 ]]
6.5 字符串运算符
=       检测两个字符串是否相等，相等返回 true          [ $a = $b ]
!=      检测两个字符串是否相等，不相等返回 true       [ $a != $b ]
-z       检测字符串长度是否为0，为0返回 true             [ -z $a ]
-n      检测字符串长度是否不为 0，不为 0 返回 true    [ -n "$a" ]
$        检测字符串是否为空，不为空返回 true              [ $a ]
6.6 文件测试运算符
-b file 检测文件是否是块设备文件，若是返回 true        [ -b $file ]
-c file  检测文件是否是字符设备文件，若是返回 true  	[ -c $file ] 
-d file  检测文件是否是目录，若是返回 true。              [ -d $file ] 
-f file   检测文件是否是普通文件（既不是目录，也不是设备文件），若是返回 true。         [ -f $file ]
-g file  检测文件是否设置了 SGID 位，若是返回 true    	[ -g $file ] 
-k file  检测文件是否设置了粘着位(Sticky Bit)，若是返回 true     	[ -k $file ]
-p file  检测文件是否是有名管道，若是返回 true            [ -p $file ]
-u file  检测文件是否设置了 SUID 位，若是返回 true     [ -u $file ] 
-r file   检测文件是否可读，若是返回 true                     [ -r $file ]
-w file  检测文件是否可写，若是返回 true                     [ -w $file ]
-x file   检测文件是否可执行，若是返回 true                  [ -x $file ]
-s file   检测文件是否为空（文件大小是否大于0），不为空返回 true  [ -s $file ]
-e file   检测文件（包括目录）是否存在，若是返回 true  [ -e $file ] 
其他检查符：
-S: 判断某文件是否 socket
-L: 检测文件是否存在并且是一个符号链接。
---------------------------------------------------------------------------------7.shell echo命令
echo "It is a test"   
echo It is a test
echo -e "OK" \n"        //-e  开启转义；\n显示换行
echo -e "OK! \c"         //-e 开启转义 \c 不换行
echo "It is a test" > myfile       显示结果定向至文件
echo '$name\"'                        原样输出字符串，不进行转义
echo `date`                              显示命令执行结果，该输出当前日期























